\chapter{Performing Inter-\/\+Process Communication}
\hypertarget{md_manual_2ipc}{}\label{md_manual_2ipc}\index{Performing Inter-\/Process Communication@{Performing Inter-\/Process Communication}}
\label{md_manual_2ipc_autotoc_md2}%
\Hypertarget{md_manual_2ipc_autotoc_md2}%
libnick uses named-\/pipes on Windows and Unix Domain Sockets on Linux to establish inter process server and client communicators, while abstracting all of that away from the consumer in the easy to use {\ttfamily Inter\+Process\+Communicator} API.

Upon creating an {\ttfamily Inter\+Process\+Communicator} object, either {\ttfamily is\+Server()} or {\ttfamily is\+Client()} will return true depending on whether or not this instance is a server or client respectively. Server instances should register a callback to the {\ttfamily Command\+Received} event to be invoked when clients send commands to the server.

NOTE\+: Whether or not {\ttfamily Inter\+Process\+Communicator} is a client or server, its object should be kept alive for the entire running of an application to avoid accidentally removing a process as the server instance if the object is destroyed midway of an application running.

Let\textquotesingle{}s consider an example scenario for using the {\ttfamily Inter\+Process\+Communicator}. Assume we have an application where we want the first instance to be considered the main, running instance. Assume that if other instances of said application are started, we want its arguments to be passed to the main instance and then have said other instances be closed. This will allow, for example, a GUI main instance to be manipulated via secondary CLI instances.

Here\textquotesingle{}s the code for this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ namespace\ }Nickvision::App;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}*[]\ argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ modernArgs;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ argc;\ i++)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(argv[i])}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ modernArgs.push\_back(\{\ argv[i]\ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{class_nickvision_1_1_app_1_1_inter_process_communicator}{InterProcessCommunicator}}\&\ ipc\{\ \textcolor{stringliteral}{"{}appid"{}}\ \};}
\DoxyCodeLine{\ \ \ \ ipc.\mbox{\hyperlink{class_nickvision_1_1_app_1_1_inter_process_communicator_a8a46d1c5270ca1b22c5685a352d58469}{commandReceived}}()\ +=\ [](\textcolor{keyword}{const}\ \mbox{\hyperlink{class_nickvision_1_1_events_1_1_param_event_args}{Events::ParamEventArgs<std::vector<std::string>}}>\&\ args)\ \{\ ...\ \};}
\DoxyCodeLine{\ \ \ \ ipc.communicate(modernArgs,\ \textcolor{keyword}{true});}
\DoxyCodeLine{\}}

\end{DoxyCode}
 If this program is ran for the first time, ipc will be the server instance. {\ttfamily handle\+Arguments} will be invoked after {\ttfamily communicate} with its own arguments, as {\ttfamily communicate} still invokes {\ttfamily Command\+Received} even if ipc is the server instance.

If this program is ran not for the first time, its arguments will be sent to the first instance and this instance itself will close. The first instance\textquotesingle{}s {\ttfamily handle\+Arguments} function will be called as a result of {\ttfamily Command\+Received} being invoked by the ipc server receiving the command. 